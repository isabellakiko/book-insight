# 项目愿景与设计

> 记录项目的动机、需求和设计理念 - 帮助 AI 理解"为什么这样做"

**创建时间**: 2025-12-09
**最后更新**: 2025-12-09

---

## 为什么做这个项目

### 阅读长篇小说的痛点

1. **人物记忆困难** - 角色众多，读到后面忘了前面的人物关系
2. **情节回顾困难** - 想找某个情节在哪一章，只能手动翻找
3. **深度理解不足** - 缺乏对人物发展、伏笔、关系变化的系统性分析

### 解决思路

用 AI 增强阅读体验：
- **不是替代阅读**，而是阅读后的辅助工具
- **基于原文**，确保信息有据可查
- **按需分析**，关注什么就分析什么

---

## 核心需求

### 人物分析（核心功能）

**需求场景**：
> "我想了解赵秦这个人物，他出现在哪些章节，每章发生了什么，整体人物发展是怎样的"

**设计要点**：
- 按需分析，而不是一次性提取所有人物
- 用户指定人物名 → 全书搜索 → 逐章分析 → 生成人物档案
- 分析结果存储，前端只展示，不实时调用 AI（省 API 费用）

**分析内容**：
- 出现在哪些章节（精确列表）
- 每章的事件、互动、代表性描述
- 人物关系
- 整体发展脉络

### RAG 问答（已完成）

**需求场景**：
> "这本书里谁和谁是什么关系？某个情节在哪一章？"

**实现方案**：
- ChromaDB 本地向量存储
- LangChain RecursiveCharacterTextSplitter 分块
- 阿里云百炼 text-embedding-v3 向量化
- 支持向量检索 + AI 生成回答

---

## 设计理念

### 1. 离线分析 + 前端展示

```
❌ 实时模式：用户点击 → 调用 AI → 等待 → 返回
✅ 离线模式：Claude Code 分析 → 存储结果 → 前端读取展示
```

**好处**：
- 节省 API 费用（只分析一次）
- 前端响应快（直接读 JSON）
- 可以人工审核、修改分析结果

### 2. 章节独立存储

```
data/books/{book_id}/chapters/
├── 0001.json    # 第1章
├── 0002.json    # 第2章
└── ...
```

**好处**：
- 人物分析时方便引用
- 知道数据来源是哪一章
- 便于后续 RAG 处理

### 3. 人物分层存储

```
data/analysis/{book_id}/characters/{name}/
├── profile.json       # 基础信息（轻量，快速加载）
└── appearances/
    ├── 0001.json      # 第1章出场详情
    └── ...            # 按需加载
```

**好处**：
- 避免单个 JSON 文件过大（主角可能出现上千章）
- 前端首屏快速加载 profile
- 用户点击某章才加载详情

---

## 当前聚焦

### 目标书籍
**《那些热血飞扬的日子》** - 7540 章

### 第一个分析人物
**赵秦** - 作为示例，验证整个分析流程

### 分析步骤
1. 拆分书籍为章节文件
2. 搜索赵秦出现的所有章节
3. 逐章分析（可能需要多次会话）
4. 生成人物档案
5. 更新前端展示

---

## 未来可能

- [ ] 支持更多书籍格式（EPUB、PDF）
- [ ] 人物关系图谱可视化（网络图）
- [ ] 多书籍对比分析
- [x] RAG 智能问答（已完成）
- [x] 情节时间线（已完成）

---

**文档定位**: 理解项目"为什么"，指导设计决策
**更新频率**: 需求或设计理念变化时
